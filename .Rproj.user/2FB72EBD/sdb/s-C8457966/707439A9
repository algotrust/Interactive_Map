{
    "contents" : "\n#Packages Needed\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(leaflet)\nlibrary(RColorBrewer)\nlibrary(scales)\nlibrary(lattice)\nlibrary(dplyr)\n\n\nd <- readRDS(\"data/data.rds\")\nd$FEATURE_NAME <- as.character(d$FEATURE_NAME)\nd$FEATURE_CLASS <- as.character(d$FEATURE_CLASS)\nd$STATE_ALPHA <- as.character(d$STATE_ALPHA)\nd$COUNTY_NAME <- as.character(d$COUNTY_NAME)\nd$ELEV_IN_M <- as.numeric(d$ELEV_IN_M)\nd$ELEV_IN_FT <- as.numeric(d$ELEV_IN_FT)\nd$classID <- as.numeric(d$classID)\nd$Group <- as.numeric(d$Group)\n\n\ncleantable <- d %>%\n  select(\n    Group = Group,\n    FeatureID = FEATURE_ID,\n    FeatureName = FEATURE_NAME,\n    FeatureClass = FEATURE_CLASS,\n    County = COUNTY_NAME,\n    State = STATE_ALPHA,\n    Elevation_Mass = ELEV_IN_M,\n    Percent_Mass = percentM,\n    Elevation_Feet = ELEV_IN_FT,\n    Percent_Feet = percentF,\n    Lat = lat,\n    Long = long\n  )\n\nfeaturedata <- d\n\nshinyServer(function(input, output, session) {\n  \n  # Create the map\n  map <- createLeafletMap(session, \"map\")\n  \n  \n \n  # The features that are within the visible bounds of the map\n  featuresInBounds <- reactive({\n    #if (input$go == 0) return(NULL)\n    if (is.null(input$map_bounds))\n      return(featuredata[FALSE,])\n    bounds <- input$map_bounds\n    latRng <- range(bounds$north, bounds$south)\n    lngRng <- range(bounds$east, bounds$west)\n    \n    featuredata <- featuredata[featuredata$FEATURE_CLASS %in% input$Featclass,]\n    \n    subset(featuredata,\n           lat >= latRng[1] & lat <= latRng[2] &\n             long >= lngRng[1] & long <= lngRng[2])\n  })\n  \n  # session$onFlushed is necessary to work around a bug in the Shiny/Leaflet\n  # integration; without it, the addCircle commands arrive in the browser\n  # before the map is created.\n  session$onFlushed(once=TRUE, function() {\n    paintObs <- observe({\n      colorBy <- input$color\n      sizeBy <- input$size\n      featuredata <- featuredata[featuredata$FEATURE_CLASS %in% input$Featclass,]\n      \n      colorData <- d[[colorBy]]\n\n      colors <- brewer.pal(8, \"Dark2\")[cut(colorData, 8, labels = FALSE)]\n      colors <- colors[match(featuredata$classID, d$classID)]\n      \n      # Clear existing circles before drawing\n      map$clearShapes()\n\n        radiusFactor <- 1000\n        try(\n          map$addCircle(\n            featuredata$lat, \n            featuredata$long,\n            ((featuredata[[sizeBy]] * 165) / max(d[[sizeBy]])) * 1500,\n            featuredata$FEATURE_NAME,\n            list(stroke=FALSE, \n                 weight=1.2,\n                 fill=TRUE, \n                 fillOpacity=0.5),\n            list(color = colors)\n          )\n       )\n   })\n      \n\n    \n    # TIL this is necessary in order to prevent the observer from\n    # attempting to write to the websocket after the session is gone.\n    session$onSessionEnded(paintObs$suspend)\n  })\n  \n# Show a popup at the given location\nshowFeaturePopup <- function(feature, lat, lng) {\n  selectedFeature <- d[d$FEATURE_NAME == feature,]\n  content <- as.character(tagList(\n    tags$h4(\"Feature Class:\", selectedFeature$FEATURE_CLASS),\n    tags$strong(HTML(sprintf(\"%s, %s %s\",\n                             selectedFeature$FEATURE_NAME, selectedFeature$COUNTY_NAME, selectedFeature$STATE_ALPHA\n    ))), \n    tags$br(),\n    sprintf(\"Elevation in Mass: %s\", selectedFeature$ELEV_IN_M), tags$br(),\n    sprintf(\"Elevation in Feet: %s\", selectedFeature$ELEV_IN_FT)\n  ))\n  map$showPopup(lat, lng, content, feature)\n}\n  # When map is clicked, show a popup with city info\n  clickObs <- observe({\n    map$clearPopups()\n    event <- input$map_shape_click\n    if (is.null(event))\n      return()\n    \n    isolate({\n      showFeaturePopup(event$id, event$lat, event$lng)\n    })\n  })\n  \n  session$onSessionEnded(clickObs$suspend)\n  \n  \n  ## EXAMPLE 1: Data Explorer ###########################################\n\nobserve({\n  \n  cleantable <- cleantable[cleantable$FeatureClass %in% input$Featclass,]\n  county <- if (is.null(input$states)) character(0) else {\n    filter(cleantable, State %in% input$states) %>%\n      `$`('County') %>%\n      unique() %>%\n      sort()\n  }\n  stillSelected <- isolate(input$county[input$county %in% county])\n  updateSelectInput(session, \"county\", choices = county,\n                    selected = stillSelected)\n})\n\nobserve({\n  \n  cleantable <- cleantable[cleantable$FeatureClass %in% input$Featclass,]\n  classes <- if (is.null(input$states)) character(0) else {\n    cleantable %>%\n      filter(State %in% input$states,\n             is.null(input$county) | County %in% input$county) %>%\n      `$`('FeatureClass') %>%\n      unique() %>%\n      sort()\n  }\n  stillSelected <- isolate(input$classes[input$classes %in% classes])\n  updateSelectInput(session, \"classes\", choices = classes,\n                    selected = stillSelected)\n})\n\n\nobserve({\n  \n  cleantable <- cleantable[cleantable$FeatureClass %in% input$Featclass,]\n  names <- if (is.null(input$states)) character(0) else {\n    cleantable %>%\n      filter(State %in% input$states,\n             is.null(input$county) | County %in% input$county,\n             is.null(input$classes) | FeatureClass %in% input$classes) %>%\n      `$`('FeatureName') %>%\n      unique() %>%\n      sort()\n  }\n  stillSelected <- isolate(input$names[input$names %in% names])\n  updateSelectInput(session, \"names\", choices = names,\n                    selected = stillSelected)\n})\n  \n  observe({\n    if (is.null(input$goto))\n      return()\n    isolate({\n      map$clearPopups()\n      dist <- 0.5\n      feature <- input$goto$feature\n      lat <- input$goto$lat\n      lng <- input$goto$lng\n      showFeaturePopup(feature, lat, lng)\n      map$fitBounds(lat - dist, lng - dist,\n                    lat + dist, lng + dist)\n    })\n  })\n  \n  output$table1 <- renderDataTable({\n    \n    if (nrow(featuresInBounds()) == 0)\n      return(NULL)\n    \n  cleantable <- cleantable[cleantable$FeatureClass %in% input$Featclass,]\n  cleantable$Group <- cleantable$Lat <- cleantable$Long <- NULL\n  cleantable %>%\n      filter(\n        is.null(input$states) | State %in% input$states,\n        is.null(input$county) | County %in% input$county,\n        is.null(input$classes) | FeatureClass %in% input$classes,\n        is.null(input$names) | FeatureName %in% input$names\n      ) #%>%\n    #mutate(Action = paste('<a class=\"go-map\" href=\"\" data-lat=\"', Lat, '\" data-long=\"', Long, '\" data-zip=\"', FeatureName, '\"><i class=\"fa fa-crosshairs\"></i></a>', sep=\"\"))\n  })#, escape = FALSE)\n  \n  \n})\n",
    "created" : 1426127012746.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "75806960",
    "id" : "707439A9",
    "lastKnownWriteTime" : 1424659922,
    "path" : "~/GitHub/Interactive_Map/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}